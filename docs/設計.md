# 設計

## 概要

- Deno Deploy でホストする
- フロントエンドは Vue.js
- バックエンドは Deno (v2)
- 入退室は REST API で通信
- 回答は WebSocket で通信
- データベースとして Deno KV を使用

## 技術的制約

- Deno Deploy でホストする。Deno Deploy ではユーザーの最も近くのエッジで実行されるため、同一ルームのユーザーが同一インスタンスに接続されるとは限らない。
  - 回答があった場合、WebSocket で接続されているユーザー全員に通知する必要があるが、別インスタンスで更新された情報をきちんと通知するためには、Deno KV を watch して、各インスタンスで情報の更新を監視し、その上で接続ユーザーに通知する必要がある。

## ユーザーストーリー

- 新しいルームを作成できる
- 既存のルームに参加できる
- ルーム内で回答を送信できる
- ルーム内で観覧者になれる
- ルーム内の他のユーザーの回答をリアルタイムで受信できる
- ルーム内の他のユーザーの入退室をリアルタイムで受信できる
- リロードしてもルームに再参加できる
- タブを閉じるとルームから退室する

## バックエンド

### やること

#### REST API

- ルーム作成を受け付け、その時点でのルーム情報を返す
- ルーム参加を受け付け、その時点でのルーム情報を返す
- ルームからの退出を受け付ける

#### WebSocket

- ルーム作成・参加時に接続を確立する
- ルーム情報が更新されたときに通知する
  - KV の変更を監視
- ユーザーの回答を受け付け、ルーム情報を更新する
- 観覧者モードの切り替えを受け付ける
- ルームの回答をクリアする

### KVS 設計

Deno KV を使用して、アプリケーションの状態を永続化し、リアルタイムな情報共有を実現します。「リロードしてもルームに再参加できる」というユーザーストーリーに対応するため、クライアントはサーバーから発行された `UserToken` を保持し、リロード時にそれを利用して復帰します。

#### 1. キー構造と役割

KVS のキーは、以下のプレフィックスと ID を組み合わせて構成します。

- `rooms:<roomId>`
  - **役割**: 特定のルームに関する全ての情報を格納します。ルーム名、参加者リスト（各参加者は `UserToken` で識別）、現在の回答状況などが含まれます。
  - **例**: `rooms:abcdef123456`
- `user_tokens:<UserToken>`
  - **役割**: サーバーが発行した `UserToken` が現在どのルームに参加しているか、最後にアクティブだったのはいつか、などの情報を保持します。これは主に、リロード時の復帰処理や、長時間応答がない場合の自動退出処理の判断材料として使用します。
  - **例**: `user_tokens:unique_user_token_string`

> **2025-06-04 設計更新:**
> UserToken は必ず`user_tokens:<UserToken>`として独立管理し、ルーム情報（`rooms:<roomId>`）の`participants`には UserToken の参照のみを持つ。UserToken 情報の重複管理は避ける。

#### 2. データモデル (Value の構造例)

##### a. ルーム情報 (`rooms:<roomId>`)

ルームの ID (`<roomId>`) をキーとし、以下の情報を持つ JSON オブジェクトを格納します。

```json
{
  "id": "string", // ルームID (キーと重複するが、データ内にも保持)
  "name": "string", // ルーム名 (ユーザーが設定可能、任意)
  "participants": {
    // key: UserToken (サーバーが発行し、クライアントが保持・再利用するトークン)
    // value: 参加者情報オブジェクト
    // 例:
    // "user_token_alice": {
    //   "token": "string", // UserToken
    //   "name": "string", // ユーザー名
    //   "isSpectator": "boolean", // 観覧者モードか否か
    //   "joinedAt": "timestamp" // 参加日時
    // }
  },
  "answers": {
    // key: UserToken
    // value: 回答内容 (例: 文字列)
    // 例:
    // "user_token_alice": "回答内容A"
  },
  "config": {
    // ルーム固有の設定など (将来的な拡張用)
    "allowSpectators": "boolean", // デフォルトtrue
    "maxParticipants": "number" // デフォルト مثلا 50
  },
  "createdAt": "timestamp", // ルーム作成日時
  "updatedAt": "timestamp" // 最終更新日時 (参加者の入退室、回答の更新など)
}
```

**考慮事項:**

- `participants` と `answers` のキーには、サーバーが発行する `UserToken` を使用します。
- `updatedAt` はルーム情報に何らかの変更があった場合に更新し、これを `Deno.Kv.watch()` で監視することで、リアルタイム更新のトリガーとします。

##### b. ユーザートークン情報 (`user_tokens:<UserToken>`)（必須）

`UserToken` をキーとし、以下の情報を持つ JSON オブジェクトを格納します。この情報は、ルーム情報と重複しないよう、セッション管理・復帰・自動退出判定などに利用します。

```json
{
  "token": "string", // UserToken (キーと重複)
  "currentRoomId": "string | null", // 現在参加中のルームID、参加していなければnull
  "name": "string", // ユーザー名
  "isSpectator": "boolean", // 観覧者モード
  "lastAccessedAt": "timestamp" // TTL設定や自動退出処理の判断材料
}
```

**考慮事項:**

- ルーム情報の`participants`には UserToken の参照のみを持ち、ユーザー名や観覧者フラグ等は`user_tokens`側で一元管理する。
- リロード時や復帰時は`user_tokens`を参照して状態を復元する。
- タブを閉じた際の退出処理や自動退出判定も`user_tokens`の`lastAccessedAt`を利用する。

#### 3. 操作と整合性

- **アトミック操作**: 参加者の追加/削除、回答の送信など、ルーム情報を変更する操作は `Deno.Kv.atomic()` を使用してデータの整合性を保ちます。
- **ID 生成**:
  - `roomId`: ルーム作成時にサーバーサイドで UUID v4 などを利用して生成します。
  - `UserToken`: ユーザーがルームに初めて参加する際、またはリロード後に有効な `UserToken` を持っていない場合に、サーバーサイドで UUID v4 などを利用して生成し、クライアントに返します。クライアントはこれを `sessionStorage` または `localStorage` に保存し、リロード時や再接続時にサーバーに送信します。
- **データの監視と通知**:
  - 特定ルームのキー (`rooms:<roomId>`) の変更を `Deno.Kv.watch()` で監視します。
  - 変更が検知されたら、そのルームに参加している WebSocket クライアントに最新のルーム情報を送信します。
  - **技術的制約への対応**: Deno Deploy では各インスタンスが独立して KV を監視します。`Deno.Kv.watch()` は同一プロセス内の変更を効率的に検知できますが、別インスタンスによる変更の即時検知と全接続クライアントへの通知には、Deno Queues を利用したブロードキャスト機構の導入や、クライアント側での定期的なポーリング（フォールバックとして）などを検討する可能性があります。まずは `watch` を基本とし、必要に応じて高度な仕組みを検討します。

#### 4. 不足情報・検討事項

現時点での設計で、以下の点は明確化が必要です。実際に実装を進める中で具体化していきます。

- **ユーザー名の重複**: 同一ルーム内でのユーザー名の重複を許容するか、あるいは何らかの形でユニークにするか（例: `Alice`, `Alice (2)`）。現状は重複を許容する想定です。
- **回答の更新/削除**: 現在の設計では回答は追記・上書きのみを想定していますが、個別の回答を削除したり、更新履歴を持たせたりする要件がある場合は、`answers` のデータ構造や操作を詳細化する必要があります。
- **エラーハンドリングの詳細**: KV 操作時のエラー（キーが存在しない、書き込み競合など）、無効な `UserToken` での復帰試行などにどう対応するか。
- **データの有効期限 (TTL)**: アクティブでないルーム情報や `UserToken` 情報を自動的にクリーンアップするための TTL 設定。`user_tokens` の `lastAccessedAt` はそのための情報の一つです。
- **`UserToken` の管理**: `user_tokens` を独立したキー構造で持つか、各ルームの `participants` 内で関連情報 (例: `lastAccessedAt`) を管理するか、どちらが効率的か検討が必要です。

### API エンドポイント設計

#### REST API

- **ルーム作成**:
  - パス: `/api/rooms`
  - メソッド: `POST`
  - リクエストボディ: `{ "roomName": "string" }` (任意)
  - レスポンスボディ (成功時): `{ "roomId": "string", "userToken": "string", "room": Room }` (Room は KVS のルーム情報)
  - レスポンスボディ (エラー時): `{ "error": "string" }`
  - ステータスコード: 成功時 `201 Created`, エラー時 `400 Bad Request` / `500 Internal Server Error`
- **ルーム参加**:
  - パス: `/api/rooms/:roomId/join`
  - メソッド: `POST`
  - リクエストボディ: `{ "userName": "string", "userToken": "string" }` (`userToken`はリロード時にクライアントが保持していれば送信)
  - レスポンスボディ (成功時): `{ "userToken": "string", "room": Room }` (新しい`userToken`が発行された場合はそれを返す)
  - レスポンスボディ (エラー時): `{ "error": "string" }` (例: ルームが存在しない、満員)
  - ステータスコード: 成功時 `200 OK`, エラー時 `400 Bad Request` / `404 Not Found` / `500 Internal Server Error`
- **ルームからの退出**:
  - パス: `/api/rooms/:roomId/leave`
  - メソッド: `POST` (または `DELETE`)
  - リクエストボディ: `{ "userToken": "string" }`
  - レスポンスボディ (成功時): `{ "message": "Successfully left the room" }`
  - レスポンスボディ (エラー時): `{ "error": "string" }`
  - ステータスコード: 成功時 `200 OK`, エラー時 `400 Bad Request` / `500 Internal Server Error`
  - 備考: `navigator.sendBeacon()` での呼び出しも考慮。

#### WebSocket

- **接続エンドポイント**:
  - パス: `/ws/rooms/:roomId?userToken=<UserToken>`
- **メッセージ形式**: JSON
- **クライアントからサーバーへのメッセージ**:
  - 回答送信: `{ "type": "submit_answer", "payload": { "answer": "string" } }`
  - 観覧者モード切替: `{ "type": "toggle_spectator", "payload": { "isSpectator": "boolean" } }`
  - 回答クリア: `{ "type": "clear_answers" }`
- **サーバーからクライアントへのメッセージ**:
  - ルーム情報更新: `{ "type": "room_update", "payload": Room }` (Room は最新のルーム情報)
  - エラー通知: `{ "type": "error", "payload": { "message": "string" } }`

### 認証・認可

- `UserToken` はクライアントのセッション（リロードを跨ぐ程度）を識別するために使用する。
- `UserToken` の寿命はルームの生存期間に依存し、比較的短いため、厳密な認証トークンとしての扱いはしない。
- ルームへのアクセスは、有効な `roomId` を知っており、かつルームがアクティブ（例: 参加者がいる、最近更新された）である場合に許可される。
- `UserToken` は、特定のルーム内でのユーザーの操作（回答、観覧モード変更など）を識別するために使用する。

### エラーハンドリング

- **REST API**:
  - リクエスト不正 (バリデーションエラー等): `400 Bad Request` と共にエラー詳細を JSON で返す。
  - リソースが見つからない (存在しないルーム ID 等): `404 Not Found`。
  - サーバー内部エラー: `500 Internal Server Error` と共に汎用的なエラーメッセージを返す。
- **WebSocket**:
  - 不正なメッセージ形式や操作: エラーメッセージを WebSocket 経由で送信し、必要に応じて接続を閉じる。
  - サーバー内部エラー: エラーメッセージを送信し、接続を維持するか閉じるかはエラーの性質による。
- **ログ**:
  - 重要な処理の開始・終了、エラー発生時には詳細なログ（タイムスタンプ、リクエスト情報、エラー内容など）を記録する。
  - Deno Deploy のロギング機能を利用する。

### 詳細処理フロー

- **ルーム作成**:
  1.  クライアントからルーム作成リクエスト (任意でルーム名を含む) を受信。
  2.  サーバーは新しい `roomId` (UUID v4) を生成。
  3.  新しい `UserToken` (UUID v4) を生成。
  4.  初期ルーム情報 (参加者としてリクエスト元ユーザーを追加) を KVS に `rooms:<roomId>` で保存 (`atomic` 操作)。
  5.  必要であれば `user_tokens:<UserToken>` に情報を保存 (検討中)。
  6.  クライアントに `roomId`, `userToken`, 初期ルーム情報を返す。
- **ルーム参加**:
  1.  クライアントからルーム参加リクエスト (`roomId`, ユーザー名、既存の `userToken` (あれば)) を受信。
  2.  `roomId` で KVS からルーム情報を取得。存在しなければエラー。
  3.  `userToken` がリクエストに含まれていれば、そのトークンが有効か（例: `user_tokens` に存在し、`currentRoomId` が一致するか、または `participants` に存在するか）を確認。
      - 有効であればその `UserToken` を使用。必要に応じてユーザー名や状態を更新。
      - 無効または提供されていない場合は新しい `UserToken` を発行。
  4.  ルーム情報に参加者としてユーザーを追加/更新 (`atomic` 操作)。`updatedAt` を更新。
  5.  クライアントに `userToken` (新規発行または既存) と最新のルーム情報を返す。
  6.  WebSocket 接続を確立。
- **回答送信**:
  1.  クライアント (WebSocket) から回答情報 (`UserToken` は接続に紐づく) を受信。
  2.  KVS の該当ルームの `answers` に回答を保存、`participants` の該当ユーザーの回答情報も更新 (`atomic` 操作)。`updatedAt` を更新。
  3.  (KV の watch 経由で) ルーム参加者全員に最新のルーム情報を送信。
- **ユーザー退出 (API 経由)**:
  1.  クライアントから退出リクエスト (`roomId`, `userToken`) を受信。
  2.  KVS のルーム情報から該当 `UserToken` の参加者を削除 (`atomic` 操作)。`updatedAt` を更新。
  3.  必要であれば `user_tokens:<UserToken>` から情報を削除または更新 (検討中)。
  4.  (KV の watch 経由で) 残りのルーム参加者に最新のルーム情報を送信。
  5.  該当ユーザーの WebSocket 接続があれば切断。
- **リロード時の復帰処理**:
  1.  クライアントは `localStorage` / `sessionStorage` から `userToken` と `roomId` を取得。
  2.  通常のルーム参加フローと同様に、`/api/rooms/:roomId/join` に `userToken` を含めてリクエスト。
  3.  サーバーは `userToken` を検証し、既存参加者として復帰させるか、新規参加者 (または新規トークンでの参加) として扱うかを判断。

### Deno KV の具体的な利用方法

- **アトミック操作 (`atomic()`)**:
  - ルーム作成時の初期データ書き込み。
  - 参加者の追加/削除とルームの `updatedAt` 更新。
  - 回答の追加/更新とルームの `updatedAt` 更新。
  - 観覧者モードの変更とルームの `updatedAt` 更新。
  - 回答クリアとルームの `updatedAt` 更新。
- **データの監視 (`watch()`)**:
  - 各 Deno Deploy インスタンスは、自身が担当するルーム (WebSocket 接続を保持しているルーム) の `rooms:<roomId>` キーを `Deno.Kv.watch()` で監視する。
  - 変更が検知されたら、最新のルーム情報を取得し、該当ルームの全 WebSocket クライアントに送信する。
- **Deno Queues**:
  - 技術的制約への対応として検討。現時点では `watch()` を基本とし、Deno Deploy の複数インスタンス間でのリアルタイム性に問題が生じた場合に、Deno Queues を利用したブロードキャスト機構（例: あるインスタンスでの KV 更新をトリガーにキューにメッセージを送信し、全インスタンスがそのキューをリッスンして WebSocket クライアントに通知する）の導入を検討する。

### セキュリティ考慮事項

- **入力値のバリデーション**:
  - ルーム名、ユーザー名、回答内容など、クライアントからの入力値は長さ、使用可能文字などを検証し、XSS などの攻撃を防ぐ。
  - Deno 標準ライブラリやサードパーティライブラリを利用したサニタイズ処理を検討。
- **WebSocket**:
  - 接続時に `Origin` ヘッダーを検証し、意図しないドメインからの接続を拒否することを検討。
  - メッセージサイズや頻度に制限を設け、DoS 攻撃のリスクを軽減することを検討。
- **その他**:
  - エラーメッセージに機密情報（スタックトレース等）が含まれないようにする。

### 環境変数・設定管理

- ログレベルや外部サービスのエンドポイントなど、環境によって変更が必要な設定は環境変数経由で読み込む。
- Deno Deploy の環境変数設定機能を利用する。
- 開発環境では `.env` ファイルなどを使用して環境変数を管理することを検討。

### テスト方針

- ローカル環境で Deno KV を実際に動作させ、API リクエストから KV のデータ変更、WebSocket 経由での通知までを一貫してテストする結合テストを主軸とする。
- テスト時には KV のデータを直接参照・検証し、期待通りの状態変化が起きているかを確認する。
- 必要に応じて、特定のロジック単位での単体テストも追加する。
